\section{Results}
In this section we illustrate some considerable results we found during the experience. The first part of the section shows the different performances reached by using the \textit{LZ77} algorithm with different lengths of the \textit{searching window}, the second part focuses on the combined effect of changing both \textit{searching window} and \textit{coding window} and the last part compares our \textit{LZ77} and \textit{LZSS} implementations with commercial softwares.

All the experiments we performed have been executed on seven specific types of files, part of them taken from the \textit{Canterbury Corpus}, a collection of files with several formats to be used as sample files for compression testing. The used files are here reported (during the experimentation and the report itself we refer to each file by its index number):

\begin{itemize}
\item
\textbf{\texttt{file\_1}}: simple text file containing a sequence of character \texttt{A} repeated $10000$ times ($10000$ bytes);

\item
\textbf{\texttt{file\_2}}: simple text file containing a repetition of the latin alphabet ($13000$ bytes);

\item
\textbf{\texttt{file\_3}}: file generated by concatening $10000$ random bytes ($10000$ bytes);

\item
\textbf{\texttt{file\_4}}: simple text file reporting a piece of a Shakespeare poem ($13741$ bytes);

\item
\textbf{\texttt{file\_5}}: html format page ($24603$ bytes);

\item
\textbf{\texttt{file\_6}}: piece of \texttt{c} code ($11150$ bytes);

\item
\textbf{\texttt{file\_7}}: SPARC executable file ($38240$ bytes).
\end{itemize}

We chose these files to have a wide span among different kinds of files and show, in this way, the several behaviours the algorithm can assume for different scenarios. In particular, we use the file \texttt{file\_1} to obtain the maximum compression capability of the algorithm, the file \texttt{file\_2} was included to show the behaviours in presence of periodicity and the file \texttt{file\_3}, which, being randomly generated has no redundancy to exploit and a high entropy, represents the worst scenario for compression purposes. The last four files, on the other hand, do  not represent borderline or special cases, but more common examples of files one can deals with during his ordinary life.

\subsection{\textit{Searching window} variations}
A big problem with implicit dictionary based compression algorithms is that periodicity of the message could not be properly exploited and thus we could be wasting compression resources. This unfavorable event occurs if the \textit{searching window} is shorter than the period of the message, such that there is no way the algorithm can become aware of the existance of periodicity in the message. We ran the algorithm on the seven chosen files using different lengths for the \textit{searching window}. Hereafter we report the obtained curves:

%\begin{center}
%\begin{figure}[H]
%\includegraphics[width=\textwidth]{report_img/snr.eps}
%\caption{Comparison between systems performances.}
%\end{figure}
%\end{center}

It is easy to see that performances tends to improve with the growing of the \textit{searching window}. We could expect such a result: with shorter windows it is more difficult to find repeated pattern to refer to and, in some cases, we could neither realize that such patterns are present in the message. For a highly redundant input stream a long window allows to encode at the same time much more repetitions; even though the number of bits needed to represent a wide range of values grows with the increasing of the window, this happens with a logarithmic trend, while the amount of space used to encode a sequence byte per byte grows linearly. Clearly the usage of large windows implies a drop of performances from a computational time point of view. 
In the best compression scenario, we would like to have a \textit{search window} as long as the message itself, but, since this is not suitable for time reason, commercial softwares usually work with block of symbols $32$ Kbyte long with windows of

\subsection{\textit{Searching window} and \textit{coding window} variations}
The \textit{LZ77} algorithm has, in fact, two parameters we can act to: the lengths of the \textit{searching window} and of the \textit{coding window}. It could be interesting wondering what happens if we stretch both the windows. From the following 2D graphs we can see that the length of the \textit{coding window} has, actually, a low impact on coding performances. The reason is that, for a redundant message, 